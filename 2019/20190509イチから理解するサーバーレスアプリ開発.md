# イチから理解するサーバーレスアプリ開発

## 概要
* 日時: 2019/05/09
* 場所: amazon
* https://understandingbasicserverlessse.splashthat.com/
* #AWSLoft



## session
-----
### サーバーレスのおさらい
* Speeker:
* Slide:

#### サーバーレス
* サーバーの存在を意識しない
  - サーバー管理が不要
  - 柔軟なスケーリング
  - 十二分に考慮された高可用性
  - アイドル時のリソース確保が不要
* アプリケーションの本質ロジック開発に注力できる
  - ユーザー責任範囲を小さく
  - 実際の処理負荷に応じて自動的に拡張・縮退
* 利用者がやること
  - アプリケーション設計
  - ロジック開発
  - DB設計
  - 監視・エラー制御
* クラウドがやること
  - リソース管理
  - 再実行処理
  - ログ管理
  - サーバー保守
#### 主要コンポーネント
* Lambda
  - FaaS
  - コード実行時に適切にインフラを確保して処理を実行
  - Java/Node.js/Go/Ruby/...
* API Gateway
  - REST API
* AppSync
  - GraphQL
* DynamoDB
  - NoSQL
* RDS/Aurora
  - RDB
* SOS
  - Queue
* S3
  - file
* Cognio
  - 認証
* KinesisDataStream
  - 流入データ

#### リソース管理
* 呼び出し要求に応じてファンクションを実行
  - 処理リソースを確保
* リクエスト増加
  - 必要に応じてリソースを追加確保
* 不適切なリソース利用の帽子
  - 同時実行数による制御・保護
* 効率的なリソース再利用の促進
  - 処理タイムアウトの設定

#### リソースにおける失敗・エラー制御の基本
* 処理リソース単位(ファウンクション)でエラー処理を考慮する
* StepFunction
  - フロー管理
  - 複数の処理を一連のフローとして管理
  - 異なる言語のファンクションの組み合わせもOK
  - 実行履歴を確認可能
    - 処理の可視性を工場

#### サーバーレスにおけるデーターベースの考え方
* 高アクセス時処理
  - Lambda入り口でスロットリング
  - DB接続数を絞る
  - 分散型DBを選択する(DynamoDB)


#### サーバーレス検討のきっかけと狙い
* タイミング
  - 新サービスの実装
  - 既存の仕組みへの機能追加
  - 既存処理の刷新
  - 既存アーキテクチャの最適化
* 検討対象領域
  - 将来予測が難しい
  - 時期・時間による変動が大きい
  * 機能変更頻度が高い
  * 多くのデータ種別を取り扱う
* SIer
  - 提案に差をつける
  - 時間をかける箇所を変える
  - サーバーレス基盤ソリューションでメリットを得る
  - 均一の品質で横展開を加速させる

-----
### サーバーレスアプリケーション向きのDB設計ベストプラクティス
* Speeker: Akihiro Tsukada @akitsukada
* Slide: https://www.slideshare.net/AmazonWebServicesJapan/db-144577033

#### サーバーレスアプリケーションとデータベースの種類
* LambdaとRDBを利用する際の考慮事項
  - スケールアウトに伴うコネクション数増加
    - RDB側にコネクションプールする機構がない
  - VPC内リソースアクセス時のコールドスタート
    - LambdaからVPC内RDBアクセスするにはLambdaにもVPCを設定しENIを設定する必要
* DynamoDB
  - コネクション数の問題から解放
  - 標準でVPCガイリソースとしてアクセス可能
  - スケーラブル

#### DynamoDBの知識とベストプラクティス
- テーブルの数は最小限に留める
- PrimaryKey
  - PartitionKとSortKeyの復号
- グローバルセカンダリインデックス
  - 元テーブルから非同期レプリケーション
  - 1テーブル1インデックスに複数種類のアイテムを持たせられる
#### データーベース設計プロセス(RDBとDynamoDB)
* RDB設計
  - 業務分析と論理データモデリング
    - ER図
  - 物理データモデリング
    - テーブル設計書
  - アプリ・SQL設計、実装
    - 実際のクエリ
* DynamoDB設計
  - 業務分析とデータのモデリング
    - ER図
  - アクセスパターン設計
    - ユースケースリスト
      - 画面からリクエストされるクエリ
  - TableとIndex設計
    - スキーマ定義書
      - ユースケースを満たせるテーブルおよびインデックスのスキーマ設計
  - クエリ設計
    - クエリ条件定義書
      - クエリの詳細を設計・定義
      - ユースケースごとに利用するパラメーター・条件等
* DynamoDBではアクセスパターンに基づいた設計が必要

#### まとめ
* サーバーレスアプリケーションにはスケーラブルなDynamoDBが使いやすい
* 公式ドキュメントのベストプラクティスを踏まえた上で設計に挑む



-----
### エラー制御・監視の勘所
* Speeker:　Takashi Koyanagawa
* Slide:

#### DynamoDBの監視とエラー対策
* API発行した時にどれくらい使用したのかを監視
  - CapacityUnit(CU)は秒単位
  - CloudWatchは分単位
    - SUMで見ないと合計値がわからない
* スロットル監視
  - テーブルのなんのオペレーションで起きたか
* システムエラー監視
  - エラー発生原因
    - 本来は起きてはいけない
* APIとCapacityUnitの消費
  - APIによって計算の概念を違う
    - リクエスト単位のデータ位サイズからの算出
      - put/get_item -> 1kb以下は4kbに切り上げ1CU消費
    - リクエストした結果の合計サイズベースでの算出
      - scan/query
    - Batchバルクオペレーション
      - 4kbの切り上げはアイテム単位
    - コンディション句
      - 評価したアイテムの数ベースでの算出
* CUにまつわるエラー対策
  - バルクオペレーション最中にエラーが発生ｓ田場合
    - return未処理アイテムが返却される
    - アプリケーション側での対処が必要
  - return-corisumed-capacity
    - 実行したAPIが消費したCUの目安を見ることができる
* CU不足？
  - CUはパーティション数で平均化される。
    - Hotパーティションを作らないような設計が必要
    - パーティション数はユーザから不可視
  - パーティションは増加方向のみ
    - 縮めれない
* TTLの活用
  - TTLはCUを消費しない
  - 48時間で削除される
    - 48時間以内のアプリケーションによる削除ははCUを消費する
* オートスケーリング利用時のCU不足
  - スパイクアクセスの対応は完全対応が難しい
  - APIコントロールorオートスケールで対応

#### StepFunctionsの監視とエラー対策
* モニタリング項目
  - StepFunctionの実行数
  - タイムアウト終了した数
  - フロー全体の処理時間
  - タイムアウト発生
  - 実行したLambdaの数
  - タイムアウトして終了したLambdaの数
* StepFunctionsの状態遷移の実行可能数
  - パケットサイズおよび1秒あたりの補充されるテートにより決まる
* エラー設計
  - stateが長期化する/終わらないものの発生
    - State machinesにタイムアウトが定義
  - Lambdaでのエラーハンドリング
  - Lambdaでのリトライ定義

#### Lambda
* 起動パターンによる起動数の違い
  - イベントベース
  - ストリームベース
    - errorを検知したら要注意
      - チェックポイントが進まない
      - 有効期限切れになるまでリトライし続けてしまう(DeadLock)
      - Lamnda正常終了させることが重要
  - SQSベース
* 共通で気をつけること
  - Throttleを観測
  - Error metrics増加
  - Dead Letter Queue増加
  - リトライ時に処理

#### まとめ
* モニタリングはヘルスチェックとして傾向変化にも気をつける
  - アラームでは遅い場合がある
  - 運用レスではない
* DynamoDB
  - CUの消費の計測方法が異なる
  - TTLやテーブル設計で無駄にCUを使用品設計
  - パーティションのｓ状態をハンドル
* StepFunctions

