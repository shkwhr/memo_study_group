# [DevLOVE Premium第3回]ドメイン駆動設計 本格入門

## 概要
* 日時: 2019/03/22
* 場所: 株式会社クラウドワークス
* #devlove
* Speeker: 増田 亨(@masuda220)


## ドメイン駆動設計 本格入門
### 考え方
* ドメイン駆動設計でなぜ作るのか
  - ソフトウェアの変更を楽で安全にするため
    - 動かすこと
    - その時のビジネスのニーズに対応している
    - 何年もソフトウェアが変化・成長を続けていくことが可能
  - 楽で安全
    - 全てにプラスに作用する
    - 最大の指標
  - 変更が厄介で危険
    - 全てにマイナスに作用する
* 変更を楽で安全にするためのやりかた
  - 関心の分離の工夫
  - モジュール構造の工夫
### 3つのキーワード
* ドメインロジック
  - 複雑さの根源
  - ≒ビジネスルール
  - ソフトウェアが複雑になる理由
    - ビジネスルールそのものはシンプル
    - ビジネスルールを適用する条件分岐が複雑
      - どこに何を追加するのか
  - 複雑さに戦う準備
    - ビジネスルールの記述を独立したルールに分離する
      - 各層がシンプルになる
        - 自動生成で済む部分が増える
    - 機能単位に分割すると条件判定記述箇所が分散・重複する
  - モデリング手法
    - Fact
      - 事実の表現
        - 数値
        - 日付
    - Rule
      - Factを使った計算や判定のロジック
    - Goal
      - 知りたいこと
        - Ruleを使った計算結果
        - Ruleを使った判定結果
* ドメインモデル
  - 複雑さをモデルで整理
  - ≒計算モデル
  - モデル
    - 全体をシンプルにとらえて説明する試み
    - 関心の分離
      - 抽象というよりは分離
        - 要点ごとの分離
        - 要点と支える部分が存在する
  - 計算モデル
    - 入出力は伴わない
    - 判定ロジックそのもの
    - メモリ上での計算
  - データモデル
    - データの記録と参照
    - 計算結果の記録
    - ソフトウェアの複雑さに立ち向かう主軸ではない
  - 計算と入出力の分離
* オブジェクト指向
  - モデルと実装の一致
  - モデルをコードで表現
  - ≒型指向のプログラミング
    - ビジネスルールの記述をモジュール化する基本
    - 値の種類ごとにモジュール(クラス)定義する
      - 値の種類ごとに独自のクラス
      - 値の種類ごとに有効な値の範囲
      - 値の種類ごとに必要な計算・判定のロジック
  - 設計パターン
    - 値オブジェクト
      - Factの表現手段
        - 値の範囲の定義
      - Ruleの置き場所
        - 計算・判定メソッド
      - Goalの表現手段
        - メソッドの返す型
      - 効果
        - 値の種類の表現の明示化
          - ビジネスロジックの記述が１箇所に集まる
            - 変更が楽で安全になる
      - 設計
        - 計算の意図をメソッド名とメソッドを返す型で説明する
        - 原則
          - 必要な計算は限定的とする
            - 拡張性は必要な時に考えれば良い
        - 契約による設計
          - 型による表明
            - 引数の型
            - 戻り値の型
            - 不正な値を持つオブジェクトを生成しない
          - 防御的な検査コードを書かない
          - 暗黙的なビジネスルールの明文化になる
    - ロジックを持つenum
      - 区分ごとのビジネスルールを扱う
        - 区分体系の問題の発見と改善が進む
          - 区分体系は論理体系になっていないことが多い
            - 区分を集約したときにコードが歪む
              - 区分のリファクタリングが必要
              - ビジネスルール記述のわかりやすさ
    - コレクションのカプセル化
      - コレクション操作
        - 問題
          - バグが紛れこみやすい
        - 改善策
          - 目的別のコレクション型を独自に作る
          - ロジックの集約
          - 詳細の隠蔽
      - カプセル化
        - 散らばっていたコードの収束
          - リファクタリングが容易になる
        - 技術手段が隠蔽される
          - 戻り値型でビジネスの関心ごとが全面に表現される
### エヴァンス本のススメ
* エヴァンス本と実践ドメイン駆動設計内容違っているのに混同してみてる人がいる
  * パターンの背景を理解する
  * パターンとパターンの関係を理解することで意味が見える
* SlackやGithubなどのQAやコメントでユビキタス言語がどれだけ使われているか
  - ユビキタス
    - エンジニアto顧客だけでなくエンジニア同士でも使用すべき
* 全体の構成
  - 俯瞰で理解する
    - 1部：概念
    - 2部：基本
      - 1,2だけではあまり役に立たない
    - 3部：役にたつモデルを手に入れるための実用的な技法
    - 4部：3部をさらに大規模、長規模に取り組むための技法
      - たぶんエヴァンスも4部は未経験内容…
* 中核
  - ３部
    - ９章
      - とにかく明示的にすることに重点
    - １０章
      - ９章をしなやかに洗練させる
  - ４部
    - １４章
      - 大規模・長規模に取り組むための準備
    - １５章
      - コアをハイライト・分離させる取り組み
    - １６章
      - 全体の共通理解
        - 知識
        - 運用
      - ビジネスルールの整理と改善
* ビジネスルールの発見と整理の枠組み
  - 責務のレイヤ
    - ポリシー
    - 約束
      - 約束して良いこと
      - 約束できないこと
    - 運用
      - 約束の履行の監視と促進の決め事
      - ポリシー
      - 約束違反
    - 能力
- ビジネスルールの3つの源泉
  - 契約
    - 約束
  - バリューチェーン
    - 約束の連鎖
  - 事業運営ポリシー
### レガシーに立ち向かう
* 心の準備（期待しない…）
  - ありがちな設計
  - ありがちな状況
  - 手がかり
    - 動いてるものを重視する
    - 実画面・実データ・実ファイル
    - 区分値
      - 複雑さの根源
      - DBの区分column
      - 画面の区分表示、選択ボックス
    - 導出項目
      - 計算・判定の結果
      - 業務マニュアル・利用ガイド・料金表…
      - ソースコード
        - マニュアルからの確認
      - ヒアリング
        - 業務運用者から異常値がないか探す
* あるべき姿の中核を見極める
  - 計算・判定に焦点を合わせる
  - 記録・参照は後回し
* あるべき姿を生み出す
  - DB
    - 導出元・導出結果だけを絞り込んだデータ
    - FACTを正しく記録するテーブルを新規設計
    - 現行から必要データを複製する仕組みづくり
  - 導出ロジックプログラミング検証
* 複雑さの核心
  - 既存区分の体系
  - 区分体系の整理
* アプリケーションとして組み立てる
  - FACTを記録したテーブル・導出プログラム
  - 計算サービス
  - 判定サービス
  - 画面
  - 外部インタフェース
  - 記録・参照するだけのデータ群
### マイクロサービスとドメイン駆動設計
* マイクロサービスアーキテクチャ
  - 開発の独立性
  - 配置と運用の独立性
    - 高可用性が求められる
      - 止まっている可能性を考慮するのは辛い
      - 遅延・リトライくらいなら…
        - k8sは実際運用するにはまだ足りないものが多く大変だと思うとのこと
* 分割の4つの軸
  - ビジネス能力
  - ドメインモデル
  - アクション志向
  - リソース志向
* 分割の方針
  - 4つの軸の組み合わせになる
    - 主軸の選択
    - 補助軸の優先順位付
    - 整合性・一貫性の維持
      - かなり大変だが頑張ればいいのができるはず
    - 最初から正しい分割はできない
    - 継続的な分割の見直しの現実性
* ドメイン駆動設計
  - マイクロサービスへの分割を目的とはしていないが
  - シンプルな設計に進化していく結果として
  - 配置・運用を実際に行うかは要件次第
* モノリスからマイクロサービスへの段階移行
  - 関心と分離とモジュール構造の改善を重ねる
    - 最初は改修が多発
      - この時点ではマイクロサービス化はできない
    - 設計が安定してから
* VETRO分析
  - ビジネスメッセージの処理
  - ５種類に分解
  - アクションごとにどのルールをどのタイミングで適応するか
  - サービスを実行するステップの分解
  - ステップごとに計算・判定をする可能性
* Saga
  - 複数トランザクションに分解する
  - ビジネス的に約束し、できなければ取り消す
    - 各処理は各commitする
    - 失敗時に代替処理を行う
      - 代替アクションの分析と実装
        - 人間系処理も代替案
    - 代替処理がなければrollbackする
  - コーディネータクラス管理
* DB
  - 変更が楽である設計
    - 事実の記録を徹底する
      - NULLという事実はない
      - オプショナル項目は別テーブルにする
      - 有効な値の範囲を定義
    - テーブル単位を計算の関心ごとに従属させる
    - 事実と参照を分ける
    - 事実と導出結果を分ける
  * 外部キー
    - 事実の前後関係
    - 同じ時点の事実を別テーブルにしている関係
  * テーブルの分割
    - 関数従属性
    - 発生時点で分解
    - 計算従属性
  * 分離独立を段階的に発展させる
    - テーブル->スキーマ->DB
    - いきなりDB単位の分割を検討しない
  * 記録・参照・事実と導出結果の分離
    - テーブルで属性を分けupdateはしない
