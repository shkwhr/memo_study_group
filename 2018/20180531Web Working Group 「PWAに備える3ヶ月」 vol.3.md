# Web Working Group 「PWAに備える3ヶ月」 vol.3

## 概要
* 日時: 2018/06/31
* 場所: GMO Yours


## session

-----
### Cache 自由自在
* Speeker: 進藤　龍之介(フリーエンジニア／NPO日本Androidの会理事) @ryu_compin
* 資料: https://www.slideshare.net/RyuShindo/cache-99772140

#### cache
##### PWAの動作
* キャッシュとオンラインコンテンツをServiceWorkerが仲立ち
  * キャッシュの扱いがキモになる

#### どう扱う
* そもそもの目的
  * 高速化
  * ネットワークの節約、オフライン対応
* 考慮点
  - 更新の反映
  - インタラクティブなコンテンツ
    - キャッシュ除外コントロールとか

#### 基本
* Cache first
  - 最初にキャッシュにアクセス
- NetWork first
  - 最初にネットワークアクセス
- No Cache
  - キャッシュにアクセスしない

#### CacheAPI
* match / matchAll
  - 検索機能
* add / addAll
  - 追加
* put
  - 追加
* delete
  - 削除
* keys
  - キー取得
* 有効期限
  - ない
  - ほっといても消えない
  - 同期、更新、削除は自分でやる必要がある

#### 制御
* SPA
  - AppShell部分とそれ以外に明確に分けるのが設計上シンプル
    - WebViewみたいな
* MultiplePage
  - サイト構成によるが、固定コンテンツとそれ以外の個別の制御
    - 個別制御が発生する
    - 一般的なWebサイトみたいな

#### 一般的なPWA Cacheの削除
* Active時に削除
  - caches.delete(key)
* 更新タイミング
  - SWはオンライン時に同期され、次回起動時に更新されたものが動作する
  - Cacheは明示的に更新するか、SWのActivate時に削除、再取得される
* 焦げ付き対策プラン
  - IndexedDBの活用
    - Cacheエントリー時にDBにタイムスタンプとURLを記録
    - 読み出し時にオンラインなら期限切れのものは削除、更新する
      - ラグはあるが焦げ付きはなくなる
  - Workboxのexpiration.Plugin
    - 時間制限をつけられる

#### フレームワークでできること
* PWA Builder
  - Microsoft
  - 必要項目を入力するとSW、Manifest、registerを生成してくれる
  - Cache制御はURI個別制御はいまのところない
  - 既存のManifestがあるとそこから読み込んでくれる
* Work Box
  - Webサイトのオフラインサポートのためのライブラリ
    - JS
  - 細かなCache制御
    - ファイル種別、URL等指定して制御可能
    - プラグインによる拡張
      - Cache保持期間指定が可能
* 組み合わせるといい感じ
  - PWA Builder -> Workbox

#### SWの仲間たち
* iOSがまだSW対応端末がすくない…


-----
### 今から開発できる、Progressive Web Apps
* Speeker: 物江 修(日本マイクロソフト株式会社パートナー事業本部テクニカルエバンジェリスト)

#### PWAについて
* WebによるネイティブのようなUX
* WebとNativeの間を埋める第３の存在
* クライアントの性能に合わせた機能提供
  - Progressive:前進
  - アプリにおけるProgressiveEnhancement
    - 端末性能によって提供機能が変わる
      - Webページ or アプリケーション
* Webになかった機能
  - オフラインサポート
  - プッシュ通知
  - バックグラウンド処理
  - アイコンの追加(インストール)
  - SW
  - WebAppManifest

* Webのメリット
  - SLICE

* PWAのメリット
  - 発見性(Storeでなく検索から)
  - インストール可能
    - インストールしなくてもいい(選択性)
  - 再エンゲージ可能
    - Push通知
  - ネットワーク非依存
  - プログレッシブ
    - どんな端末でも使える
  - レスポンシブ
    - どんな端末でも使える
  - 安全
    - ブラウザのサンドボックス上で動く
  - リンク可能
    - リンクでアプリの共有が可能

#### PWAを実現するAPI
* SW
  - バックグラウンドで動作するプログラミング可能なネットワークプロキシ
  - WebWorkerの一つ
    - WOMに直接アクセスできない
  - Webページと異なるライフサイクル
  - HTTPS必須
  - 単純にページ読み込み速度を早くするためだけでもできる
* BackgroundSyncAPI以外はどの端末でもほぼ使える
* SW使う準備
  - SW用のJSファイルが必要
    - Webサイト/アプリ + SW用JSファイル
  - SWは配置された配下のアセットを制御
  - Step1. SWの登録
  - Step2. アセットのキャッシュ
    - キャッシュするアセットを登録
  - Step3. 有効かイベント
    - 既存のキャッシュの一覧を取り出す
    - この後処理くらいでキャッシュを削除
  - Step4. リクエストのハンドリング
    - キャッシュからのデータが利用可能かどうか確認
      - キャッシュかfetchでネトワークから取得した内容を返す
* キャッシュ
  - AppShell
    - UIが機能するために必要最小限のリソース
    - 要件にあったアセット
      - ユーザーストレージ容量を意識する
  - ServiceWorkerの更新
    - jsファイルを更新
      - js更新してもキャッシュがクリアされるわけではない
      - 有効になるのは一度ページを閉じた後

#### WebAppManifest
* サイトのブックマークを端末のホーム画面に追加
  * アプリケーションを起動するさいの情報
  * json形式
  * linkタグでManifest参照
* Windowsの対応はまだ(Edgeは対応しているが…)
* icons
  - ブラウザによって定義を切り替える
* start_url
  - ブラウザからかPWAとして呼ばれたかURIで定義できる
* display
  - 優先されるビューの設定
  - 4種類指定が可能


#### PWA on Windows
* Storeで後悔する2つの方法
  - Bing 自動インデックス(beta)
    - HTTPSセキュアなエンドポイント
      - sonarwhal
        - 品質検証ツール
    - 高品質のmanifest
    - オフラインのサポート
    - ストアの審査をパス
    - Windowsならではの差別化がされている
  - 検出されないようにするには
    - Robot.txt
    - display:browser
    - 電話すると消してもらえる
  - セルフパブリッシング
    - UWPと同じ
      - VSかpwabuilderCLI等で審査
    - AppX提出
* WindowsStoreAppの価値
  - デベロッパーセンターの分析機能
  - アプリ内課金
  - プロモーションの機会
  - データーストレージの上限がない
  - WindowsRT APIにアクセス可能


#### PWA Builder
* ホストされているPWAパッケージング

#### 価値をたかめるAPI
* CSS3
  - GPUによる滑らかなレンダリング
* WebAssembly
  - 高速な演算
* WebVR
  - よりImmersiveな体験
* WebPayments
  - 独自決済(裏で決済サービスと繋ぐ)


-----
### PWAの機能の選択と選択について
* Speeker: eegozilla (html5j運営スタッフ／日本Androidの会 運営委員) @ega1979

#### 作ったサイト
* POSTIE
  - 言語ごとにPWA化
* ABC2018 SPRING
  - SPA部分のみPWA化

##### 注意事項
* WebAPPとPWAの内容は基本は同じ
  - 出し分けはあらかじめ設計が必要

#### a
1. ServiceWorkerでキャッシュするファイルを決める
  * ローカルで見せることで効果のあるファイルを選択する
2. スコープ / start_url を決める
  * ユーザー再来訪するページを指定すると良さげ
    - TOPページとは限らない
3. PWAするスコープを決める
  * 一度読み込まないとSWの恩恵をうけない
  * SPA化すると一括で対象にできる
4. オフライン制御
  * オフラインであることを明示するのが望ましい
  * リアルタイム情報を扱う場合はユーザーが認識できるようにする必要がる

#### OS間の再から考えるPWA対応
* アイコン
  * iOS
    - apple-touch-iconを参照
  * Android
    - manifestで定義したもので端末に最適なサイズが選択される
  - ブランドにあったものを別に用意することができる
* スプラッシュ画面
  - Androidのみ
  - ローディングアニメーション
    - スプラッシュからローディングになると待ち時間が長くなるのでやらないようにする
* テーマカラー
  - ブランドカラーに合わせて選択する
* ブラウザバックの有無
  - iOS
    - Standalone/FullScreenの場合UIが存在しないのでUIを用意する必要がある
    - ナビゲーションはどのコンテンツに行くかを明確にする
* iOS問題
  - Basic認証
    - manifest.jsonやapple-touch-iconが参照できない
  - Standaloneモードのとき自動リーダーのアイコンが表示されない

#### 思ったこと
* PWAはエンゲージメントが閾値をこえたユーザーへのおもてなし
  - PWAとすることで有益な体験となるように
  - 初回ユーザー向けではあまりない気がする
    - PWAで体験の提供するのではなくWebコンテンツ自体の体験が大事
* OSに差異がある
  - ターゲットを考える
  - 汎用配布であれば差異をカバーするUIなどが必要
* PWAは一回入れると後戻りしづらい
  - なんらかトラブルがでてくる
* ユーザーにとってなにがProgressiveかを考える
* デザイナーだけでの最適な設計は困難
  - エンジニアがしっかりはいって手動で設計を考えたほうがいい


-----
###　フリートーク

* BingからStore登録されたら作成者に連絡いく？
  - いかないでしょう。誰が作ったかわかんないし
* スコープ範囲外の遷移はどうする
  - スコープ外はPWAでないのでアプリ内ブラウザで処理させるのがよい
  - 明示的に違うドメインだとブラウザで開く
  - WordPressとの相性はあんまりよくない
    - URLをいじくってくる
* PWAどうしでインテントってできる？
  - 挙動があやしい
  - 動かしてみて確認し(トラブっ)たほうがいい
  - 今の所明示てきに行うAPIがなさそう
* 全て動的なWebページの場合のcacheは？
  - NetworkFirstにしてfetchに失敗したらcacheを表示するようにしてあげるといい
* PWA削除したらプッシュ通知は届く？
  - SWがなくなるので届かない
  - iOSはバックグラウンド処理を許さない



-----
###
* Speeker:

####
#####
* a


-----
###
* Speeker:

####
#####
* a
